// Mapeos de caracteres Unicode para Mathematical Sans
const mathSansNormal = {
    'A': '𝖠', 'B': '𝖡', 'C': '𝖢', 'D': '𝖣', 'E': '𝖤', 'F': '𝖥', 'G': '𝖦', 'H': '𝖧', 'I': '𝖨', 'J': '𝖩',
    'K': '𝖪', 'L': '𝖫', 'M': '𝖬', 'N': '𝖭', 'O': '𝖮', 'P': '𝖯', 'Q': '𝖰', 'R': '𝖱', 'S': '𝖲', 'T': '𝖳',
    'U': '𝖴', 'V': '𝖵', 'W': '𝖶', 'X': '𝖷', 'Y': '𝖸', 'Z': '𝖹',
    'a': '𝖺', 'b': '𝖻', 'c': '𝖼', 'd': '𝖽', 'e': '𝖾', 'f': '𝖿', 'g': '𝗀', 'h': '𝗁', 'i': '𝗂', 'j': '𝗃',
    'k': '𝗄', 'l': '𝗅', 'm': '𝗆', 'n': '𝗇', 'o': '𝗈', 'p': '𝗉', 'q': '𝗊', 'r': '𝗋', 's': '𝗌', 't': '𝗍',
    'u': '𝗎', 'v': '𝗏', 'w': '𝗐', 'x': '𝗑', 'y': '𝗒', 'z': '𝗓',
    '0': '𝟢', '1': '𝟣', '2': '𝟤', '3': '𝟥', '4': '𝟦', '5': '𝟧', '6': '𝟨', '7': '𝟩', '8': '𝟪', '9': '𝟫'
};

const mathSansBold = {
    'A': '𝗔', 'B': '𝗕', 'C': '𝗖', 'D': '𝗗', 'E': '𝗘', 'F': '𝗙', 'G': '𝗚', 'H': '𝗛', 'I': '𝗜', 'J': '𝗝',
    'K': '𝗞', 'L': '𝗟', 'M': '𝗠', 'N': '𝗡', 'O': '𝗢', 'P': '𝗣', 'Q': '𝗤', 'R': '𝗥', 'S': '𝗦', 'T': '𝗧',
    'U': '𝗨', 'V': '𝗩', 'W': '𝗪', 'X': '𝗫', 'Y': '𝗬', 'Z': '𝗭',
    'a': '𝗮', 'b': '𝗯', 'c': '𝗰', 'd': '𝗱', 'e': '𝗲', 'f': '𝗳', 'g': '𝗴', 'h': '𝗵', 'i': '𝗶', 'j': '𝗷',
    'k': '𝗸', 'l': '𝗹', 'm': '𝗺', 'n': '𝗻', 'o': '𝗼', 'p': '𝗽', 'q': '𝗾', 'r': '𝗿', 's': '𝘀', 't': '𝘁',
    'u': '𝘂', 'v': '𝘃', 'w': '𝘄', 'x': '𝘅', 'y': '𝘆', 'z': '𝘇',
    '0': '𝟬', '1': '𝟭', '2': '𝟮', '3': '𝟯', '4': '𝟰', '5': '𝟱', '6': '𝟲', '7': '𝟳', '8': '𝟴', '9': '𝟵'
};

const mathSansItalic = {
    'A': '𝘈', 'B': '𝘉', 'C': '𝘊', 'D': '𝘋', 'E': '𝘌', 'F': '𝘍', 'G': '𝘎', 'H': '𝘏', 'I': '𝘐', 'J': '𝘑',
    'K': '𝘒', 'L': '𝘓', 'M': '𝘔', 'N': '𝘕', 'O': '𝘖', 'P': '𝘗', 'Q': '𝘘', 'R': '𝘙', 'S': '𝘚', 'T': '𝘛',
    'U': '𝘜', 'V': '𝘝', 'W': '𝘞', 'X': '𝘟', 'Y': '𝘠', 'Z': '𝘡',
    'a': '𝘢', 'b': '𝘣', 'c': '𝘤', 'd': '𝘥', 'e': '𝘦', 'f': '𝘧', 'g': '𝘨', 'h': '𝘩', 'i': '𝘪', 'j': '𝘫',
    'k': '𝘬', 'l': '𝘭', 'm': '𝘮', 'n': '𝘯', 'o': '𝘰', 'p': '𝘱', 'q': '𝘲', 'r': '𝘳', 's': '𝘴', 't': '𝘵',
    'u': '𝘶', 'v': '𝘷', 'w': '𝘸', 'x': '𝘹', 'y': '𝘺', 'z': '𝘻'
};

const mathSansBoldItalic = {
    'A': '𝘼', 'B': '𝘽', 'C': '𝘾', 'D': '𝘿', 'E': '𝙀', 'F': '𝙁', 'G': '𝙂', 'H': '𝙃', 'I': '𝙄', 'J': '𝙅',
    'K': '𝙆', 'L': '𝙇', 'M': '𝙈', 'N': '𝙉', 'O': '𝙊', 'P': '𝙋', 'Q': '𝙌', 'R': '𝙍', 'S': '𝙎', 'T': '𝙏',
    'U': '𝙐', 'V': '𝙑', 'W': '𝙒', 'X': '𝙓', 'Y': '𝙔', 'Z': '𝙕',
    'a': '𝙖', 'b': '𝙗', 'c': '𝙘', 'd': '𝙙', 'e': '𝙚', 'f': '𝙛', 'g': '𝙜', 'h': '𝙝', 'i': '𝙞', 'j': '𝙟',
    'k': '𝙠', 'l': '𝙡', 'm': '𝙢', 'n': '𝙣', 'o': '𝙤', 'p': '𝙥', 'q': '𝙦', 'r': '𝙧', 's': '𝙨', 't': '𝙩',
    'u': '𝙪', 'v': '𝙫', 'w': '𝙬', 'x': '𝙭', 'y': '𝙮', 'z': '𝙯'
};

// Estado de la aplicación
let currentFormat = 'normal';

// Elementos del DOM
const textEditor = document.getElementById('textEditor');
const copyBtn = document.getElementById('copyBtn');
const formatButtons = document.querySelectorAll('.new-format-btn');

// Mapeos inversos para convertir de nuevo a normal
const mathSansBoldReverse = Object.fromEntries(Object.entries(mathSansBold).map(([key, value]) => [value, key]));
const mathSansItalicReverse = Object.fromEntries(Object.entries(mathSansItalic).map(([key, value]) => [value, key]));
const mathSansBoldItalicReverse = Object.fromEntries(Object.entries(mathSansBoldItalic).map(([key, value]) => [value, key]));

// Función para convertir texto según el formato seleccionado, handling existing formats
function convertText(text, format) {
    // First, convert any existing formatted characters back to normal
    let normalText = '';
    for (const char of text) {
        if (mathSansBoldReverse[char]) {
            normalText += mathSansBoldReverse[char];
        } else if (mathSansItalicReverse[char]) {
            normalText += mathSansItalicReverse[char];
        } else if (mathSansBoldItalicReverse[char]) {
            normalText += mathSansBoldItalicReverse[char];
        } else {
            normalText += char;
        }
    }
    
    // If the target format is 'normal', return the normalized text directly
    if (format === 'normal') {
        return normalText;
    }

    // Otherwise, apply the new format mapping to the normalized text
    let mapping;
    switch (format) {
        case 'bold':
            mapping = mathSansBold;
            break;
        case 'italic':
            mapping = mathSansItalic;
            break;
        case 'bolditalic':
            mapping = mathSansBoldItalic;
            break;
        default:
             // This case should ideally not be reached if format buttons are correctly set
             mapping = mathSansNormal;
    }
    
    return normalText.split('').map(char => mapping[char] || char).join('');
}

// Función para aplicar formato al texto seleccionado
function applyFormatToSelection() {
    const selection = window.getSelection();
    
    if (selection.rangeCount === 0) return;
    
    const range = selection.getRangeAt(0);
    const selectedText = range.toString();
    
    if (selectedText.length === 0) return;
    
    // The convertText function now handles converting from any format to the target format
    const processedText = convertText(selectedText, currentFormat);
    
    // Reemplazar el texto seleccionado con el texto procesado
    range.deleteContents();
    range.insertNode(document.createTextNode(processedText));
    
    // Limpiar la selección
    selection.removeAllRanges();
}

// Manejo de botones de formato
formatButtons.forEach(button => {
    button.addEventListener('click', () => {
        // Remover clase active de todos los botones
        formatButtons.forEach(btn => btn.classList.remove('active'));
        
        // Agregar clase active al botón clickeado
        button.classList.add('active');
        
        // Actualizar formato actual
        currentFormat = button.dataset.format;
        
        // Aplicar formato si hay texto seleccionado
        applyFormatToSelection();
        
        // Mantener el foco en el editor
        textEditor.focus();
    });
});


// Función para copiar al portapapeles
async function copyToClipboard() {
    const textToCopy = textEditor.textContent;
    
    if (!textToCopy.trim()) {
        return;
    }
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        
        // Feedback visual
        const originalText = copyBtn.textContent;
        copyBtn.textContent = '✅ ¡Copiado!';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove('copied');
        }, 2000);
        
    } catch (err) {
        // Fallback para navegadores más antiguos
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        document.body.appendChild(textArea);
        textArea.select();
        
        try {
            document.execCommand('copy');
            copyBtn.textContent = '✅ ¡Copiado!';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
                copyBtn.textContent = '📋 Copiar';
                copyBtn.classList.remove('copied');
            }, 2000);
        } catch (fallbackErr) {
            console.error('Error al copiar:', fallbackErr);
            alert('No se pudo copiar el texto. Por favor, selecciona y copia manualmente.');
        }
        
        document.body.removeChild(textArea);
    }
}

// Inicialización
document.addEventListener('DOMContentLoaded', () => {
    textEditor.focus();
    console.log('LinkedIn Sans Stylizer cargado correctamente');
    // Añadir el event listener aquí, solo si copyBtn existe
    if (copyBtn) {
        copyBtn.addEventListener('click', copyToClipboard);
    }
    
    // Manejar teclas de acceso rápido
    textEditor.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
            switch (e.key) {
                case 'b':
                    e.preventDefault();
                    document.querySelector('[data-format="bold"]').click();
                    break;
                case 'i':
                    e.preventDefault();
                    document.querySelector('[data-format="italic"]').click();
                    break;
            }
        }
    });
});